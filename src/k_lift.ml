(*
    This file is a part of ficus language project.
    See ficus/LICENSE for the licensing terms
*)

(*
    Full-scale lambda lifting.
    Unlike k_simple_ll, this algorithm
    moves all the functions to the top level.

    Also, unlike k_simple_ll, this algorithm is executed after all
    other K-form optimizations, including dead code elimination,
    tail-recursive call elimination, inline expansion etc.
    (But dead code elimination runs once again after it to remove
    some of the generated by this step structures and functions that are not used)

    In order to move all the functions to the top level and preserve
    semantics of the original code, we need to transform some nested functions,
    as well as some outer code that uses those functions.

    * We analyze each function and see if the function has 'free variables',
      i.e. variables that are defined outside of this function and yet are non-global.
    a)  If the function has some 'free variables',
        it needs a special satellite structure called 'closure data'
        that incapsulates all the free variables. The function itself
        is transformed, it gets an extra parameter, which is pointer to the
        closure data (this is done at C code generation step actually).
        All the accesses to free variables are replaced
        with the closure data access operations. Then, when the function
        occurs in code (if it does not occur, it's eliminated as dead code),
        a 'closure' is created, which is a pair (function_pointer, (closure_data or 'nil')).
        This pair is used instead of the original function. Here is the example:

        fun foo(n: int) {
            fun bar(m: int) = m * n
            bar
        }

        is replaced with

        fun bar(m: int, c: bar_closure_t) {
            m * c->n
        }
        fun foo(n: int) {
            make_closure(bar, bar_closure_t {n})
        }

    b)  If the function does not have any 'free variables', we may still
        need a closure, i.e. we may need to represent this function as a pair,
        because in general when we pass a function as a parameter to another function
        or store it as a value (essentially, we store a function pointer), the caller
        of that function does not know whether the called function needs free variables or not,
        so we need a consistent representation of functions that are called indirectly.
        But in this case we can have a pair ('some function', nil), i.e. we just use something like
        NULL pointer instead of a pointer to real closure. So, the following code:

        fun foo(n: int) {
            fun bar(m: int) = m*n // uses free variable 'n'
            fun baz(m: int) = m+1 // does not use any free variables
            if generate_random_number() % 2 == 0 {bar} else {baz}
        }
        val transform_f = foo(5)
        for i <- 0:10 {println(transform_f(i))}

        is transformed to:

        fun bar( m: int, c: bar_closure_t* ) = m*c->n
        fun baz( m: int, _: nil_closure_t* ) = m+1

        fun foo(n: int) =
            if generate_random_number() % 2 == 0
                {make_closure(bar, bar_closure_t {n})}
            else
                {make_closure(baz, nil)}

        val (transform_f_ptr, transform_f_cldata) = foo(5)
        for i <- 0:10 {println(transform_f_ptr(i, transform_f_cldata))}

        However, in the case (b) when we call the function directly, e.g.
        we call 'baz' as 'baz' directly, not via 'transform_f' pointer, we can
        avoid the closure creation step and just call it as, e.g., 'baz(real_arg, nil)'.

    From the above description it may seem that the algorithm is very simple,
    but there are some nuances:

    1.  The nested function with free variables may not just read some values
        declared outside, it may modify mutable values, i.e. var's.
        Or, it may read from a 'var', and yet it may call another nested function
        that may access the same 'var' and modify it. We could have stored an address
        of each var in the closure data, but that would be unsafe, because we may
        return the created closure outside of the function
        (which is a typical functional language pattern for generators, see below)
        where 'var' does not exist anymore. The robust solution for this problem is
        to convert each 'var', which is used at least once as a free variable,
        into a reference, which is allocated on heap:

        fun create_incremetor(start: int) {
            var v = start
            fun inc_me() {
                val temp = v; v += 1; temp
            }
            inc_me
        }
        val counter = create_incrementor(5)
        for i<-0:10 {print(f"{counter()} ")} // 5 6 7 8 ...

        this is converted to:

        fun inc_me( c: inc_me_closure_t* ) {
            val temp = *c->v; *c->v += 1; temp
        }
        fun create_incrementor(start: int) {
            val v = ref(start)
            make_closure(inc_me, inc_me_closure_t {v})
        }

    2.  Besides the free variables, the nested function may also call:
        2a. itself. This is a simple case. We just call it and pass the same closure data, e.g.:
          fun bar( n: int, c: bar_closure_t* ) = if n <= 1 {1} else { ... bar(n-1, c) }
        2b. another function that needs some free variables from the outer scope
            fun foo(n: int) {
                fun bar(m: int) = baz(m+1)
                fun baz(m: int) = m*n
                (bar, baz)
            }

            in order to form the closure for 'baz', 'bar' needs to read 'n' value,
            which it does not access directly. That is, the code can be converted to:

            // option 1: dynamically created closure
            fun bar( m: int, c:bar_closure_t* ) {
                val (baz_cl_f, baz_cl_fv) = make_closure(baz, baz_closure_t {c->n})
                baz_cl_f(m+1, baz_cl_fv)
            }
            fun baz( m: int, c:baz_closure_t* ) = m*c->n
            fun foo(n: int) = (make_closure(bar, bar_closure_t {n}),
                               make_closure(baz, baz_closure_t {n})

            or it can be converted to

            // option 2: nested closure
            fun bar( m: int, c:bar_closure_t* ) {
                val (baz_cl_f, baz_cl_fv) = c->baz_cl
                baz_cl_f(m+1, baz_cl_fv)
            }
            fun baz( m: int, c:baz_closure_t* ) = m*c->n
            fun foo(n: int) = {
                val baz_cl = make_closure(baz, baz_closure_t {n})
                val bar_cl = make_closure(bar, {baz_cl})
                (bar_cl, baz_cl)
            }

            or it can be converted to

            // option 3: shared closure
            fun bar( m: int, c:foo_nested_closure_t* ) {
                baz(m+1, c)
            }
            fun baz( m: int, c:foo_nested_closure_t* ) = m*c->n
            fun foo(n: int) = {
                val foo_nested_closure_data = foo_nested_closure_t {n}
                val bar_cl = make_closure(bar, foo_nested_closure_data)
                val baz_cl = make_closure(baz, foo_nested_closure_data)
                (bar_cl, baz_cl)
            }

        The third option in this example is the most efficient. But in general it may
        be not easy to implement, because between bar() and baz() declarations there
        can be some value definitions, i.e. in general baz() may access some values that
        are computed using bar(), and then the properly initialized shared closure may be
        difficult to build.

        The second option is also efficient, because we avoid repetitive call to
        make_closure() inside bar(). However if not only 'bar' calls 'baz',
        but also 'baz' calls 'bar', it means that both closures need to reference each other,
        so we have a reference cycle and this couple of closures
        (or, in general, a cluster of closures) will never be released.

        So, for simplicity, we just implement the first, i.e. the slowest option.
        It's not a big problem though, because:
        * the language makes an active use of dynamic data structures
          (recursive variants, lists, arrays, strings, references ...) anyway,
          and so the memory allocation is used often, but it's tuned to be efficient,
          especially for small memory blocks.
        * when we get to the lambda lifting
          stage, we already have expanded many function calls inline
        * the remaining non-expanded nested functions that do not need
          free variables are called directly without creating a closure
        * when we have some critical hotspots, we can transform the critical functions and
          pass some 'free variables' as parameters in order to eliminate closure creation.
          (normally hotspot functions operate on huge arrays and/or they can be
          transformed into tail-recursive functions, so 'mutually-recursive functions'
          and 'hotspots' are the words that rarely occur in the same sentence).
        [TODO] The options 1, 2 and 3 are not mutually exclusive; for example, we can use
        the most efficient 3rd option in some easy-to-detect partial cases
        (e.g. when the nested functions go sequentially without any non-trivially
        defined values between them) and use the first option everywhere else.

    3.  In order to implement the first option (2.2b.1) above we need to create an
        iterative algorithm to compute the extended sets of free variables for each
        function. First, for each function we find the directly accessed free variables.
        Then we check which functions we call from this function and combine their
        free variables with the directly accessible ones, and add free variables
        from functions they call etc. We continue to do so until all the sets of
        free variables for all the functions are stabilized and do not change
        on the next iteration.
*)

open Ast
open K_form

type ll_func_info_t = { mutable ll_fvars: IdSet.t; ll_declared_inside: IdSet.t; ll_called_funcs: IdSet.t }
type ll_env_t = ll_func_info_t Env.t
type ll_subst_env_t = (id_t*id_t*(ktyp_t option)) Env.t

let make_wrappers_for_nothrow top_code =
    let rec wrapf_atom a loc callb =
        match a with
        | AtomId (Id.Name _) -> a
        | AtomId n ->
            (match (kinfo_ n loc) with
            | KFun {contents={kf_closure={kci_wrap_f}}} ->
                if kci_wrap_f = noid then a else (AtomId kci_wrap_f)
            | _ -> a)
        | _ -> a
    and wrapf_ktyp_ t loc callb = t
    and wrapf_kexp_ e callb =
        match e with
        | KDefFun kf ->
            let {kf_name; kf_args; kf_rt; kf_flags; kf_body; kf_closure; kf_scope; kf_loc } = !kf in
            let new_body = wrapf_kexp_ kf_body callb in
            let _ = kf := {!kf with kf_body=new_body} in
            if (not kf_flags.fun_flag_nothrow) ||
               (is_fun_ctor kf_flags) ||
               (kf_closure.kci_wrap_f <> noid)
            then e
            else
                (let w_name = gen_idk ((pp_id2str kf_name) ^ "_w") in
                let _ = kf := {!kf with kf_closure={kf_closure with kci_wrap_f=w_name}} in
                let w_flags = {kf_flags with fun_flag_nothrow=false} in
                let w_args = List.map (fun (a, t) ->
                    let w_a = dup_idk a in
                    let _ = create_kdefval w_a t (default_arg_flags()) None [] kf_loc in
                    (w_a, t)) kf_args
                    in
                let w_body = KExpCall(kf_name, (List.map (fun (i, _) -> AtomId i) w_args), (kf_rt, kf_loc)) in
                let code = create_kdeffun w_name w_args kf_rt w_flags (Some w_body) [e] kf_scope kf_loc in
                rcode2kexp code kf_loc)
        | KExpCall(f, args, (t, loc)) ->
            let args = List.map (fun a -> wrapf_atom a loc callb) args in
            (* leave 'f' as-is: do not transform direct calls (except for the args) *)
            KExpCall(f, args, (t, loc))
        | _ -> walk_kexp e callb
    in
    let callb =
    {
        kcb_ktyp=Some(wrapf_ktyp_);
        kcb_kexp=Some(wrapf_kexp_);
        kcb_atom=Some(wrapf_atom)
    }
    in
    let top_kexp = code2kexp top_code noloc in
    (* do 2 passes to cover both forward and backward references *)
    let top_kexp = wrapf_kexp_ top_kexp callb in
    let top_kexp = wrapf_kexp_ top_kexp callb in
    kexp2code top_kexp

let lift_all kmods =
    let globals = ref (List.fold_left (fun globals {km_top} -> K_simple_ll.find_globals km_top globals) IdSet.empty kmods) in
    let is_global n = IdSet.mem n !globals in
    let ll_env = ref (Env.empty : ll_env_t) in
    let orig_subst_env = ref (Env.empty: ll_subst_env_t) in

    let fold_fv0_ktyp_ t loc callb = () in
    let fold_fv0_kexp_ e callb =
        fold_kexp e callb; (* process all the sub-expressions in any case *)
        match e with
        (* some extra processing for each function *)
        | KDefFun {contents={kf_name; kf_loc}} ->
            let (uv, dv) = used_decl_by_kexp e in
            (* from the set of free variables we exclude global functions, values and types
               because they do not have to be put into a closure anyway *)
            let fv0 = IdSet.diff (IdSet.diff uv dv) !globals in
            let called_funcs = IdSet.fold (fun n called_funcs ->
                match (kinfo_ n kf_loc) with
                | KFun _ ->
                    if (is_global n) then called_funcs
                    else IdSet.add n called_funcs
                | _ -> called_funcs) uv IdSet.empty in
            let fv0 = IdSet.filter (fun fv -> match (kinfo_ fv kf_loc) with
                | KVal _ -> true
                | _ -> false) fv0 in
            ll_env := Env.add kf_name {ll_fvars=fv0; ll_declared_inside=dv; ll_called_funcs=called_funcs} !ll_env
        | _ -> ()
    in let fv0_callb =
    {
        kcb_fold_atom = None;
        kcb_fold_ktyp = Some(fold_fv0_ktyp_);
        kcb_fold_kexp = Some(fold_fv0_kexp_);
        kcb_fold_result = 0
    } in
    (* for each function, top-level or not, find the initial set of free variables,
       as well as the set of called functions *)
    let _ = List.iter (fun {km_top} -> List.iter (fun e -> fold_fv0_kexp_ e fv0_callb) km_top) kmods in

    (* now expand those sets. recursively add to the list of free variables
       all the free variables from the called functions
       (but not defined locally) *)
    let rec finalize_sets iters ll_all =
        let visited_funcs = ref IdSet.empty in
        let changed = ref false in
        let _ = if iters > 0 then () else raise_compile_err noloc
            "finalization of the free var sets takes too much iterations" in
        let rec update_fvars f =
            match (Env.find_opt f !ll_env) with
            | Some ll_info ->
                let { ll_fvars; ll_declared_inside; ll_called_funcs } = ll_info in
                if IdSet.mem f !visited_funcs then ll_fvars
                else
                    let _ = visited_funcs := IdSet.add f !visited_funcs in
                    let size0 = IdSet.cardinal ll_fvars in
                    let fvars = IdSet.fold (fun called_f fvars ->
                        let called_fvars = update_fvars called_f in
                        IdSet.union fvars called_fvars) ll_called_funcs ll_fvars in
                    let fvars = IdSet.diff fvars ll_declared_inside in
                    let size1 = IdSet.cardinal fvars in
                    let _ = if size1 = size0 then () else
                        (ll_info.ll_fvars <- fvars; changed := true) in
                    fvars
            | _ -> IdSet.empty
        in List.iter (fun f -> ignore (update_fvars f)) ll_all;
        if not !changed then (iters-1) else finalize_sets (iters - 1) (List.rev ll_all)
    in let iters0 = 10 in
    let _ = finalize_sets iters0 (List.rev (Env.fold (fun f _ ll_all -> f :: ll_all) !ll_env [])) in
    let all_fvars = Env.fold (fun _ ll_info all_fvars ->
        IdSet.union (ll_info.ll_fvars) all_fvars) !ll_env IdSet.empty in
    let all_mut_fvars = IdSet.filter (fun i -> is_mutable i (get_idk_loc i noloc)) all_fvars in
    (*
      for each mutable variable:
      - convert its type from 't' to 't*' (reference)
      - remove ValMutable flag
    *)
    let _ = IdSet.iter (fun mut_fv ->
        let kv = get_kval mut_fv noloc in
        let { kv_name; kv_typ; kv_flags; kv_loc } = kv in
        let new_kv_name = gen_temp_idk ((pp_id2str kv_name) ^ "_ref") in
        let new_kv_typ = KTypRef(kv_typ) in
        let new_kv_flags = {kv_flags with val_flag_mutable=false} in
        let new_kv = { kv_name=new_kv_name; kv_cname=""; kv_typ=new_kv_typ; kv_flags=new_kv_flags; kv_loc } in
        let new_old_kv = { kv with kv_flags={kv_flags with val_flag_tempref=true} } in
        set_idk_entry new_kv_name (KVal new_kv);
        set_idk_entry kv_name (KVal new_old_kv);
        (* in the original function where mutable free var is declared,
           we retain its name in most operations except for KExpMkClosure,
           where we use just created reference *)
        orig_subst_env := Env.add kv_name (kv_name, new_kv_name, None) !orig_subst_env)
        all_mut_fvars in
    (* iterate through all the functions; for each function with
       free variables define a closure and add an extra parameter *)
    let fold_defcl_ktyp_ t loc callb = () in
    let fold_defcl_kexp_ e callb =
        fold_kexp e callb; (* process all the sub-expressions in any case *)
        match e with
        | KDefFun kf ->
            let {kf_name; kf_args; kf_rt; kf_closure; kf_scope; kf_loc} = !kf in
            (match Env.find_opt kf_name !ll_env with
            | Some ll_info ->
                let fvars = ll_info.ll_fvars in
                if (IdSet.is_empty fvars) then ()
                else
                (let fvar_pairs_to_sort = IdSet.fold (fun fv fvars_to_sort ->
                    ((id2str fv), fv) :: fvars_to_sort) fvars [] in
                let fvar_pairs_sorted = List.sort (fun (a, _) (b, _) -> String.compare a b) fvar_pairs_to_sort in
                let fvars_final = List.map (fun (_, fv) -> fv) fvar_pairs_sorted in
                let fcv_tn = gen_temp_idk ((id2prefix kf_name) ^ "_closure") in
                let (_, make_args, fvars_wt) = List.fold_left (fun (idx, make_args, fvars_wt) fv ->
                    let { kv_name; kv_typ; kv_flags; kv_loc } = get_kval fv kf_loc in
                    let kv_typ = if IdSet.mem fv all_mut_fvars then KTypRef kv_typ else kv_typ in
                    let new_fv = dup_idk fv in
                    let arg = get_id (sprintf "arg%d" idx) in
                    let _ = create_kdefval new_fv kv_typ kv_flags None [] kv_loc in
                    (idx+1, (arg :: make_args), ((new_fv, kv_typ) :: fvars_wt))) (0, [], []) fvars_final in
                let fcv_t = ref { kcv_name=fcv_tn; kcv_cname=""; kcv_freevars=(List.rev fvars_wt);
                    kcv_orig_freevars=fvars_final; kcv_scope=kf_scope; kcv_loc=kf_loc } in
                let (_, make_args_ktyps) = Utils.unzip fvars_wt in
                let kf_typ = get_kf_typ kf_args kf_rt in
                let cl_arg = gen_temp_idk "cv" in
                let make_fp = gen_temp_idk "make_fp" in
                let _ = create_kdefconstr make_fp (List.rev make_args_ktyps) kf_typ
                                            (CtorFP kf_name) [] kf_scope kf_loc in
                let _ = create_kdefval cl_arg (KTypName fcv_tn) (default_val_flags()) None [] kf_loc in
                let new_kf_closure = {kf_closure with kci_arg=cl_arg; kci_fcv_t=fcv_tn; kci_make_fp=make_fp} in
                set_idk_entry fcv_tn (KClosureVars fcv_t);
                kf := { !kf with kf_closure=new_kf_closure })
            | _ -> ())
        | _ -> ()
    in let defcl_callb =
    {
        kcb_fold_atom = None;
        kcb_fold_ktyp = Some(fold_defcl_ktyp_);
        kcb_fold_kexp = Some(fold_defcl_kexp_);
        kcb_fold_result = 0
    } in

    let defined_so_far = ref IdSet.empty in
    let curr_clo = ref (noid, noid, noid) in
    let curr_top_code = ref ([]: kexp_t list) in
    let curr_subst_env = ref (Env.empty : ll_subst_env_t) in
    let curr_lift_extra_decls = ref ([]: kexp_t list) in
    let add_to_defined_so_far i =
        defined_so_far := IdSet.add i !defined_so_far in

    let rec walk_atom_n_lift_all_adv a loc get_mkclosure_arg =
        match a with
        | AtomId (Id.Name _) -> a
        | AtomId n ->
            (match (Env.find_opt n !curr_subst_env) with
            | Some ((_, _, (Some f_typ))) ->
                let temp_cl = dup_idk n in
                let make_cl = KExpMkClosure(noid, n, [], (f_typ, loc)) in
                let _ = curr_lift_extra_decls := create_kdefval temp_cl f_typ
                    (default_val_flags()) (Some make_cl) !curr_lift_extra_decls loc in
                AtomId temp_cl
            | Some ((nv, nr, _)) ->
                if get_mkclosure_arg then (AtomId nr) else (AtomId nv)
            | _ ->
                (match (kinfo_ n loc) with
                | KFun {contents={kf_flags}} ->
                    if is_fun_ctor kf_flags then ()
                    else raise_compile_err loc
                        (sprintf "for the function '%s' there is no corresponding closure" (id2str n))
                | _ -> ());
                if not get_mkclosure_arg then a
                else
                    (match (Env.find_opt n !orig_subst_env) with
                    | Some ((_, nr, _)) -> AtomId nr
                    | _ -> a))
        | _ -> a
    and walk_atom_n_lift_all a loc callb = walk_atom_n_lift_all_adv a loc false
    and walk_ktyp_n_lift_all t loc callb = t
    and walk_kexp_n_lift_all e callb =
        let saved_extra_decls = !curr_lift_extra_decls in
        let _ = curr_lift_extra_decls := [] in
        let e =
        (match e with
        | KDefFun kf  ->
            let { kf_name; kf_args; kf_rt; kf_body; kf_closure; kf_scope; kf_loc } = !kf in
            let { kci_arg; kci_fcv_t; kci_make_fp; kci_wrap_f } = kf_closure in

            let create_defclosure kf code loc =
                let {kf_name; kf_args; kf_rt; kf_closure={kci_make_fp=make_fp}; kf_flags; kf_scope; kf_loc} = !kf in
                let kf_typ = get_kf_typ kf_args kf_rt in
                let (_, orig_freevars) = get_closure_freevars kf_name kf_loc in
                if orig_freevars = [] then
                    (if is_fun_ctor kf_flags then () else
                        curr_subst_env := Env.add kf_name (noid, noid, (Some kf_typ)) !curr_subst_env;
                    (KExpNop loc) :: code)
                else
                    let cl_name = dup_idk kf_name in
                    let _ = curr_subst_env := Env.add kf_name (cl_name, cl_name, None) !curr_subst_env in
                    let _ = add_to_defined_so_far cl_name in
                    let cl_args = List.map (fun fv ->
                        if IdSet.mem fv !defined_so_far then ()
                        else raise_compile_err kf_loc
                            (sprintf "free variable '%s' of '%s' is not defined yet"
                            (id2str fv) (id2str kf_name));
                        walk_atom_n_lift_all_adv (AtomId fv) kf_loc true) orig_freevars
                        in
                    let make_cl = KExpMkClosure(make_fp, kf_name, cl_args, (kf_typ, kf_loc)) in
                    create_kdefval cl_name kf_typ (default_val_flags()) (Some make_cl) code kf_loc
                in

            let def_fcv_t_n_make =
                if kci_fcv_t = noid then [] else
                    let kcv = match (kinfo_ kci_fcv_t kf_loc) with
                    | KClosureVars kcv -> kcv
                    | _ -> raise_compile_err kf_loc
                        (sprintf "closure type '%s' for '%s' information is not valid (should be KClosureVars ...)"
                        (id2str kci_fcv_t) (id2str kf_name))
                    in
                    let make_kf = match (kinfo_ kci_make_fp kf_loc) with
                    | KFun make_kf -> make_kf
                    | _ -> raise_compile_err kf_loc
                        (sprintf "make_fp '%s' for '%s' information is not valid (should be KClosureVars ...)"
                        (id2str kci_make_fp) (id2str kf_name))
                    in
                    [KDefFun make_kf; KDefClosureVars kcv]
                in

            let out_e =
                if kci_wrap_f <> noid then
                    (KDefFun kf)
                else
                    let extra_code = create_defclosure kf [] kf_loc in
                    let _ = curr_top_code := (List.tl extra_code) @ def_fcv_t_n_make @ [KDefFun kf] @ !curr_top_code in
                    List.hd extra_code
                in

            let saved_dsf = !defined_so_far in
            let saved_clo = !curr_clo in
            let saved_subst_env = !curr_subst_env in
            let _ = curr_clo := (kf_name, kci_arg, kci_fcv_t) in
            let _ = List.iter (fun (arg, _) -> add_to_defined_so_far arg) kf_args in
            (*let _ = printf "\n\n==================================================\nprocessing %s:\n" (id2str kf_name) in
            let _ = flush_all () in
            let _ = K_pp.pprint_kexp_x (KDefFun kf) in
            let _ = printf "\n==================================================\n" in*)

            let prologue =
                if kci_fcv_t = noid then [] else
                    let kcv = match (kinfo_ kci_fcv_t kf_loc) with
                        | KClosureVars kcv -> kcv
                        | _ -> raise_compile_err kf_loc
                            (sprintf "closure type '%s' for '%s' information is not valid (should be KClosureVars ...)"
                            (id2str kci_fcv_t) (id2str kf_name))
                        in
                    let {kcv_freevars; kcv_orig_freevars} = !kcv in
                    (* for each free variable 'fv' we create a proxy 'val fv_proxy = kf_cl_arg.fv'
                      and add it to the function prologue. We also add the pair (fv, fv_proxy)
                      to the substitution dictionary. That is, we convert all the
                      accesses to the free variables *)
                    let (_, prologue) = List.fold_left2 (fun (idx, prologue) (fv, t) fv_orig ->
                        let _ = if IdSet.mem fv_orig !defined_so_far then () else
                            raise_compile_err kf_loc
                            (sprintf "free variable '%s' of function '%s' is not defined before the function body"
                            (id2str fv_orig) (id2str kf_name)) in
                        let fv_proxy = dup_idk fv in
                        let _ = add_to_defined_so_far fv_proxy in
                        let (t, kv_flags) = match (kinfo_ fv_orig kf_loc) with
                            | KVal {kv_typ; kv_flags} -> (kv_typ, kv_flags)
                            | _ -> (t, default_val_flags()) in
                        let is_mutable = IdSet.mem fv_orig all_mut_fvars in
                        let kv_flags = {kv_flags with
                            val_flag_tempref=false;
                            val_flag_arg=false;
                            val_flag_global=[]
                            } in
                        let (e, prologue, fv_proxy_mkclo_arg) =
                            if not is_mutable then
                                (KExpMem(kci_arg, idx, (t, kf_loc)), prologue, fv_proxy)
                            else
                                let ref_typ = KTypRef t in
                                let fv_ref = gen_idk ((pp_id2str fv) ^ "_ref") in
                                let get_fv = KExpMem(kci_arg, idx, (ref_typ, kf_loc)) in
                                let ref_flags = {kv_flags with
                                    val_flag_tempref=true;
                                    val_flag_mutable=false;
                                    val_flag_global=[]} in
                                let prologue = create_kdefval fv_ref ref_typ ref_flags
                                    (Some get_fv) prologue kf_loc in
                                (KExpUnOp(OpDeref, (AtomId fv_ref), (t, kf_loc)), prologue, fv_ref)
                            in
                        let _ = curr_subst_env := Env.add fv_orig (fv_proxy, fv_proxy_mkclo_arg, None) !curr_subst_env in
                        let new_kv_flags = {kv_flags with val_flag_tempref=true} in
                        let prologue = create_kdefval fv_proxy t new_kv_flags (Some e) prologue kf_loc in
                        (idx+1, prologue)) (0, []) kcv_freevars kcv_orig_freevars in
                    (* we also create a closure for each function with free variables
                        that is called from 'kf_name', but is not declared in 'kf_name' *)
                    match Env.find_opt kf_name !ll_env with
                    | Some ({ll_declared_inside; ll_called_funcs}) ->
                        let called_fs = IdSet.diff ll_called_funcs ll_declared_inside in
                        IdSet.fold (fun called_f prologue ->
                            match (kinfo_ called_f kf_loc) with
                            | KFun called_kf ->
                                let {kf_closure={kci_fcv_t=called_fcv_t}} = !called_kf in
                                if called_fcv_t = noid then prologue
                                else create_defclosure called_kf prologue kf_loc
                            | _ -> prologue) called_fs prologue
                    | _ -> raise_compile_err kf_loc
                        (sprintf "missing 'lambda lifting' information about function '%s'"
                        (id2str kf_name))
                in
            (* add the generated prologue to the function body, then transform it alltogether *)
            let body_loc = get_kexp_loc kf_body in
            let body = code2kexp ((List.rev prologue) @ (kexp2code kf_body)) body_loc in
            let body = walk_kexp_n_lift_all body callb in
            defined_so_far := saved_dsf;
            curr_clo := saved_clo;
            curr_subst_env := saved_subst_env;
            kf := {!kf with kf_body=body};

            (*printf "finished processing %s\n" (id2str kf_name);*)
            out_e
        | KDefExn {contents={ke_tag}} ->
            add_to_defined_so_far ke_tag;
            walk_kexp e callb
        | KDefVal(n, rhs, loc) ->
            let rhs = walk_kexp_n_lift_all rhs callb in
            let is_mutable_fvar = IdSet.mem n all_mut_fvars in
            add_to_defined_so_far n;
            if not is_mutable_fvar then
                KDefVal(n, rhs, loc)
            else
                let t = get_kexp_typ rhs in
                let ref_typ = KTypRef t in
                let nr =
                    match (Env.find_opt n !orig_subst_env) with
                    | Some ((_, nr, None)) -> nr
                    | _ -> raise_compile_err loc
                        (sprintf "k-lift: not found subst info about mutable free var '%s'" (id2str n))
                    in
                let (a, code) = kexp2atom ((pp_id2str n) ^ "_arg") rhs false [] in
                let code = KDefVal(nr, KExpUnOp(OpMkRef, a, (ref_typ, loc)), loc) :: code in
                let code = KDefVal(n, KExpUnOp(OpDeref, (AtomId nr), (t, loc)), loc) :: code in
                KExpSeq((List.rev code), (KTypVoid, loc))
        | KExpFor(idom_l, at_ids, body, flags, loc) ->
            let idom_l = List.map (fun (i, dom_i) ->
                let dom_i = check_n_walk_dom dom_i loc callb in
                add_to_defined_so_far i; (i, dom_i)) idom_l in
            let _ = List.iter (fun i -> add_to_defined_so_far i) at_ids in
            let body = walk_kexp_n_lift_all body callb in
            KExpFor(idom_l, at_ids, body, flags, loc)
        | KExpMap(e_idom_ll, body, flags, ((etyp, eloc) as kctx)) ->
            let e_idom_ll = List.map (fun (e, idom_l, at_ids) ->
                let e = walk_kexp_n_lift_all e callb in
                let idom_l = List.map (fun (i, dom_i) ->
                    let dom_i = check_n_walk_dom dom_i eloc callb in
                    add_to_defined_so_far i; (i, dom_i)) idom_l in
                List.iter (fun i -> add_to_defined_so_far i) at_ids;
                (e, idom_l, at_ids)) e_idom_ll
            in let body = walk_kexp_n_lift_all body callb in
            KExpMap(e_idom_ll, body, flags, kctx)
        | KExpMkClosure(make_fp, f, args, (typ, loc)) ->
            let args = List.map (fun a -> walk_atom_n_lift_all_adv a loc true) args in
            KExpMkClosure(make_fp, f, args, (typ, loc))
        | KExpCall(f, args, ((_, loc) as kctx)) ->
            let args = List.map (fun a -> walk_atom_n_lift_all a loc callb) args in
            let (curr_f, curr_arg, curr_fvt_t) = !curr_clo in
            if f = curr_f then
                (*let cl_arg =
                    if curr_cl_arg = noid then AtomLit KLitNil
                    else AtomId curr_cl_arg
                in KExpCall(f, args @ [cl_arg], kctx)*)
                KExpCall(f, args, kctx)
            else
                (match (kinfo_ f loc) with
                | KFun {contents={kf_closure={kci_fcv_t}}} ->
                    if kci_fcv_t = noid then
                        KExpCall(f, args, kctx)
                    else
                        KExpCall((check_n_walk_id f loc callb), args, kctx)
                | _ -> KExpCall((check_n_walk_id f loc callb), args, kctx))
        | _ -> walk_kexp e callb)
        in
        let e = if !curr_lift_extra_decls = [] then e
            else rcode2kexp (e :: !curr_lift_extra_decls) (get_kexp_loc e) in
        curr_lift_extra_decls := saved_extra_decls;
        e
    in let walk_n_lift_all_callb =
    {
        kcb_atom = Some(walk_atom_n_lift_all);
        kcb_ktyp = Some(walk_ktyp_n_lift_all);
        kcb_kexp = Some(walk_kexp_n_lift_all)
    } in

    List.map (fun km ->
        let {km_top} = km in
        let new_top = make_wrappers_for_nothrow km_top in
        let _ = curr_top_code := [] in
        (* recursively process each top-level expression; define the closures etc. *)
        List.iter (fun e -> fold_defcl_kexp_ e defcl_callb) new_top;
        List.iter (fun e ->
            let e = walk_kexp_n_lift_all e walk_n_lift_all_callb in
            curr_top_code := e :: !curr_top_code) new_top;
        {km with km_top=List.rev !curr_top_code}) kmods
